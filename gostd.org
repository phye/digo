#+Title: Understanding Go STD
#+Author: Philip Ye(phye8080@gmail.com)
#+STARTUP: overview
#+STARTUP: hidestars

* context
  ~Context~ type carries deadlines, cancelation signals, and other
  request-scoped values across API boundaries and between processes. 

** context.go
*** Variables
**** [[file:/usr/local/go/src/context/context.go::var%20Canceled%20%3D%20errors.New("context%20canceled")][Canceled]]
     The error returned by ~Context.Err~ when the context is canceled

**** [[file:/usr/local/go/src/context/context.go::var%20DeadlineExceeded%20error%20%3D%20deadlineExceededError{}][DeadlineExceeded]]
     The error returned by ~Context.Err~ when the context's deadline passes

**** [[file:/usr/local/go/src/context/context.go::todo%20%3D%20new(emptyCtx)][todo = new(emptyCtx)]]
     The internal non-nil, empty Context
  
**** [[file:/usr/local/go/src/context/context.go::background%20%3D%20new(emptyCtx)][background = new(emptyCtx)]]
     The internal non-nil, empty Context named backgroud

*** Types
**** [[file:/usr/local/go/src/context/context.go::type%20emptyCtx%20int][type emptyCtx int]]
     An emptyCtx is never canceled, has no values, and has no deadline. Note that
     it is not struct{}, since vars of this type *must* have distinct addresses. 

     emptyCtx implements the following (empty) methods required by Context

     [[file:/usr/local/go/src/context/context.go::func%20(*emptyCtx)%20Deadline()%20(deadline%20time.Time,%20ok%20bool)%20{][func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {]]
     [[file:/usr/local/go/src/context/context.go::func%20(*emptyCtx)%20Done()%20<-chan%20struct{}%20{][func (*emptyCtx) Done() <-chan struct{} {]]
     [[file:/usr/local/go/src/context/context.go::func%20(*emptyCtx)%20Err()%20error%20{][func (*emptyCtx) Err() error {]]
     [[file:/usr/local/go/src/context/context.go::func%20(*emptyCtx)%20Value(key%20interface{})%20interface{}%20{][func (*emptyCtx) Value(key interface{}) interface{} {]]

**** [[file:/usr/local/go/src/context/context.go::type%20canceler%20interface%20{][type canceler interface {]]
     #+begin_src go
     type canceler interface {
         cancel(removeFromParent bool, err error)
         Done() <- chan struct{}
     }
     #+end_src
     A canceler is a context type that can be canceled directly. The
     implementations are ~*cancelCtx~ and ~*timerCtx~

**** [[file:/usr/local/go/src/context/context.go::type%20cancelCtx%20struct%20{][type cancelCtx struct {]]
     #+begin_src go
     type cancelCtx struct {
         Context                     // Note that, cancelCtx is a struct, not interface :)

         mu sync.Mutex
         done chan struct{}
         children map[canceler]struct{}
         err error
     }
     #+end_src

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*cancelCtx)%20Done()%20<-chan%20struct{}%20{][func (c *cancelCtx) Done() <-chan struct{} {]]
      *atomically* make a ~chan struct{}~ and return it. Note that calling
      ~cancelCtx.Done~ will override ~cancelCtx.Context.Done~. 

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*cancelCtx)%20Err()%20error%20{][func (c *cancelCtx) Err() error {]]
      *atomically* return c.err. Also override ~cnacelCtx.Context.Err~ 

***** Puzzles
      Why ~Deadline()~ and ~Value()~ are not implemented? 
      Since they're implemented in ~canCtx.Context~. 

      Note that cancelCtx is a struct, not an interface :) Thus the
      corresponding methods in ~canCtx.Context~ is sufficient.

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*cancelCtx)%20cancel(removeFromParent%20bool,%20err%20error)%20{][func (c *cancelCtx) cancel(removeFromParent bool, err error) {]]
      *Atomically* closes c.done, then cancels each of c's children. And if
      ~removeFromParent~ is true, removes c from its parent's ~children~ map
      
**** [[file:/usr/local/go/src/context/context.go::type%20timerCtx%20struct%20{][type timerCtx struct {]]
     #+begin_src go
     type timerCtx struct {
         cancelCtx
         timer *time.Timer // Under cancelCtx.mu.

         deadline time.Time
     }
     #+end_src

     A timerCtx *contains* a cancelCtx (which evetually contains a Context), but
     overrides the ~Context~'s Deadline() method

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*timerCtx)%20Deadline()%20(deadline%20time.Time,%20ok%20bool)%20{][/usr/local/go/src/context/context.go::func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {]]
      Simpler getter to return deadline

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*timerCtx)%20cancel(removeFromParent%20bool,%20err%20error)%20{][func (c *timerCtx) cancel(removeFromParent bool, err error) {]]
      Cancel the timerCtx and stop the timer
      - Cancel the inner cancelCtx first
      - Then, remove the context itself from the parent cancelCtx if
        ~removeFromParent~ is true
      - Lastly, stop timer atomically

**** [[file:/usr/local/go/src/context/context.go::type%20valueCtx%20struct%20{][type valueCtx struct {]]
     #+begin_src go
     type valueCtx struct {
         Context
         key, val interface{}
     }
     #+end_src

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*valueCtx)%20Value(key%20interface{})%20interface{}%20{][func (c *valueCtx) Value(key interface{}) interface{} {]]
      Return value that matches with key


**** [[file:/usr/local/go/src/context/context.go::type%20Context%20interface%20{][type Context interface {]]
     #+begin_src go
     type Context interface {
         Deadline() (deadline time.Time, ok bool)
         Done() <-chan struct{}
         Err() error
         Value(key interface{}) interface{}
     }
     #+end_src
     
     ~Deadline~ returns the time when work done on behalf of this context
     should be canceled. ~Deadline~ returns ok==false when no deadline is
     set. Successive calls to ~Deadline~ return the same results. 
     
     ~Done~ returns a channel that's closed when work don on behalf of this
     context should be canceled. Done may return nil if this context can never be
     canceled. Successive calls to Done return the same value.
     
     If ~Done~ is not yet closed, ~Err~ returns nil. If ~Done~ is closed, ~Err~
     returns a non-nil error explaining why: 

       - Canceled if the context was canceled
       - DeadlineExceeded if the context's deadline passed
       
     ~Value~ returns the value associated with this context for key, or nil if no
     value is associated with key. A key identifies a specific value in a
     Context. *A key can be any type that supports equality.*

**** [[file:/usr/local/go/src/context/context.go::type%20CancelFunc%20func()][type CancelFunc func()]]
     A CancelFunc tells an operation to abandon its work. After the first call,
     subsequent calls to a CancelFunc do nothing
     
*** Functions
**** [[file:/usr/local/go/src/context/context.go::func%20removeChild(parent%20Context,%20child%20canceler)%20{][func removeChild(parent Context, child canceler) {]]
     Remove ~child~ from ~parent~ context

**** [[file:/usr/local/go/src/context/context.go::func%20newCancelCtx(parent%20Context)%20cancelCtx%20{][func newCancelCtx(parent Context) cancelCtx {]]
     Return a new ~cancelCtx~ where ~parent~ is passed as the ~Context~ 

**** [[file:/usr/local/go/src/context/context.go::func%20parentCancelCtx(parent%20Context)%20(*cancelCtx,%20bool)%20{][func parentCancelCtx(parent Context) (*cancelCtx, bool) {]]
     Follows a chain of parent references until it finds a *cancelCtx. This
     function iterate over all the concrete ~Context~ types in the =context=
     package

**** [[file:/usr/local/go/src/context/context.go::func%20propagateCancel(parent%20Context,%20child%20canceler)%20{][func propagateCancel(parent Context, child canceler) {]]
     Summary: Arranges for child to be canceled when parent is. 
     1. If parent will never be canceled, return directly

     2. Otherwise, try to find the *nearest* parent ~cancelCtx~
        - If such one is found
          - Already canceled? 
            cancel child directly
          - Not canceled yet
            Insert child into parent ~cancelCtx~'s /children/ map *atomically*
        - Otherwise, do not have a parent cancelCtx
          Start a go routine to wait on parent's cancel channel and child's
          cancel channel
          - If parent is canceled, continue to cancel child
          - If child is canceld, nothing to do

            
**** [[file:/usr/local/go/src/context/context.go::func%20Background()%20Context%20{][func Background() Context {]]
     Return the internal background empty Context

**** [[file:/usr/local/go/src/context/context.go::func%20TODO()%20Context%20{][func TODO() Context {]]
     Return the internal todo empty Context

**** [[file:/usr/local/go/src/context/context.go::func%20WithCancel(parent%20Context)%20(ctx%20Context,%20cancel%20CancelFunc)%20{][func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {]]
     WithCancel returns a copy of parent with a new Done channel. The returned
     context's Done channel is closed when the returned cancel function is
     called or when the parent context's Done channel is closed, whichever
     happens first. 

**** [[file:/usr/local/go/src/context/context.go::func%20WithDeadline(parent%20Context,%20d%20time.Time)%20(Context,%20CancelFunc)%20{][func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {]]
     Summary: Returns a copy of the parent context with the deadline adjusted to
     be no later than d. The returned context's Done channel is closed *1)* when
     the deadline expires, *2)* when the returned cancel function is called, or
     *3)* when the parent context's Done channel is closed, whichever happens
     first.  

     - check if the parent's deadline is before myself; if yes, return
       cancelCtx with parent
     - Otherwise, create a new timerCtx with a new cancelCtx after parent and
       the deadline ~d~
     - Then, insert the new timerCtx into parent's children map
     - Then, check if the timer already expires
       - If yes 
         - cancel the newly created timerCtx directly
         - return the newly created timerCtx
       - Otherwise,
         - start a timer *atomically* with a callback to cancel the timerCtx
           after timer expires
         - Lastly, return the timerCtx and a new CancelFunc

**** [[file:/usr/local/go/src/context/context.go::func%20WithTimeout(parent%20Context,%20timeout%20time.Duration)%20(Context,%20CancelFunc)%20{][func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {]]
     Simple wrapper over WithDeadline for easy use

**** [[file:/usr/local/go/src/context/context.go::func%20WithValue(parent%20Context,%20key,%20val%20interface{})%20Context%20{][func WithValue(parent Context, key, val interface{}) Context {]]
     Return a new ValueCtx with key and val set. Note that ~key~ must be
     comparable and should not be of type string or other built-in type to avoid
     collisions between packages using context. 
* net 
** mac.go                                                                       :mac:
*** Types
**** [[file:/usr/local/go/src/net/mac.go::type%20HardwareAddr%20%5B%5Dbyte][HardwareAddr]]
     HardwareAddr represents a physical address
     
***** [[file:/usr/local/go/src/net/mac.go::func%20(a%20HardwareAddr)%20String()%20string%20{][String()]]
      Convert internal physical addr to human readable

***** [[file:/usr/local/go/src/net/mac.go::func%20ParseMAC(s%20string)%20(hw%20HardwareAddr,%20err%20error)%20{][ParseMAC(s string)]]
      Convert human readable MAC to internal byte slice based MAC
      Note that normally MAC address are of 6 bytes, however, there're also [[file:/usr/local/go/src/net/mac.go::/%2001:23:45:67:89:ab:cd:ef][8
      bytes]] and [[file:/usr/local/go/src/net/mac.go::/%2001:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00][20 bytes]] MAC 

** ip.go
*** Types
**** [[file:/usr/local/go/src/net/ip.go::type%20IP%20\%5B%5Dbyte][IP]]                                                                         :ip:
     IP is a single IP address, which can either by IPv4 or IPv6. 

***** [[file:/usr/local/go/src/net/ip.go::var%20v4InV6Prefix%20%3D%20%5B%5Dbyte{0,%200,%200,%200,%200,%200,%200,%200,%200,%200,%200xff,%200xff}][v4InV6Prefix (10 zeros, 2 0xFFs)]] 
      Note that IPv4 can be converted to IPv6 address by adding a canonical

***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20Equal(x%20IP)%20bool%20{][func (ip IP) Equal(x IP) bool {]]
      Compare if two IP are equal (taking IPv4 and IPv6 comparison into consideration)

***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20To4()%20IP%20{][func (ip IP) To4() IP {]]
***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20To16()%20IP%20{][func (ip IP) To16() IP {]]
      Two utils to convert IP to v4 or v6

***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20Mask(mask%20IPMask)%20IP%20{][func (ip IP) Mask(mask IPMask) IP {]]
      Return the result of masking the IP address ip with mask
    
***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20String()%20string%20{][func (ip IP) String() string {]]
      Return the string form of the IP address ip:
        - "<nil>", if ip has length 0
        - dotted form, for an IPv4 address
        - colon form: for IPv6
        - hexadecimal form of IP, without punctuation, if no other cases apply

***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20MarshalText()%20(\%5B%5Dbyte,%20error)%20{][func (ip *IP) MarshalText()]]
      Implements the encoding.TextMarshaler interface, *the encoding is the same as
      returned by String*. 

***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20*IP)%20UnmarshalText(text%20%5B%5Dbyte)%20error%20{][func (ip *IP) UnmarshalText(text {}byte) error]]
      Implements the encoding.TextUnmarshaler interface, the IP address should be
      in dot form (for v4) or colon form (for v6)

**** [[file:/usr/local/go/src/net/ip.go::type%20IPMask%20\%5B%5Dbyte][IPMask]]                                                                     :ipmask:
***** [[file:/usr/local/go/src/net/ip.go::func%20(m%20IPMask)%20Size()%20(ones,%20bits%20int)%20{][func (m IPMask) Size() (ones, bits int) {]]
      Return number of leading ones and total bits in the mask

***** [[file:/usr/local/go/src/net/ip.go::func%20(m%20IPMask)%20String()%20string%20{][func (m IPMask) String() string {]]
      Return the hexadecimal form of IP, without punctuation

**** [[file:/usr/local/go/src/net/ip.go::type%20IPNet%20struct%20{][IPNet]]                                                                      :ipnet:
     IPNet represents an IP network with IP and IPMask

***** [[file:/usr/local/go/src/net/ip.go::func%20(n%20*IPNet)%20Contains(ip%20IP)%20bool%20{][func (n *IPNet) Contains(ip IP) bool {]]
      Returns whether the network includes ip

***** [[file:/usr/local/go/src/net/ip.go::func%20(n%20*IPNet)%20String()%20string%20{][func (n *IPNet) String() string {]]
      Returns the CIDR notation of n like "192.0.2.1/24", or "2001:db8::/48". Note
      that if the network is not in the canonical form, it will return mask as
      hexadecimal form without punctuation like "198.51.100.1/c000ff00"

*** Functions 
**** [[file:/usr/local/go/src/net/ip.go::func%20CIDRMask(ones,%20bits%20int)%20IPMask%20{][CIDRMask]] returns an IPMask 

**** [[file:/usr/local/go/src/net/ip.go::func%20ParseIP(s%20string)%20IP%20{][func ParseIP(s string) IP {]]
     Parse s as an IP address, returning the result. Support both IPv4 and IPv6.
   
**** [[file:/usr/local/go/src/net/ip.go::func%20ParseCIDR(s%20string)%20(IP,%20*IPNet,%20error)%20{][func ParseCIDR(s string) (IP, *IPNet, error) {]]
     Parses s as a CIDR notation IP address and prefix length, returns the IP
     address and the network implied by the IP and prefix length. 

**** TODO [[file:/usr/local/go/src/net/ip.go::func%20parseIPv6(s%20string,%20zoneAllowed%20bool)%20(ip%20IP,%20zone%20string)%20{][parseIPv6]]
     Parse IPv6 address

** lookup.go
*** Variables
**** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20MarshalText()%20(%5B%5Dbyte,%20error)%20{][dnsWaitGroup]]
     A internal wait group to wait for all goroutines to finish
    
**** [[file:/usr/local/go/src/net/lookup.go::var%20DefaultResolver%20%3D%20&Resolver{}][DefaultResolver]]
     Default *package-level* Lookup functions and by Dialers without a specified
     Resolver 
   
*** Types
**** [[file:/usr/local/go/src/net/lookup.go::type%20Resolver%20struct%20{][type Resolver struct {]]
     A ~Resolver~ looks up names and numbers. 

     #+begin_src go
     type Resolver struct {
         PreferGo bool
         StrictErrors bool
         Dial func(ctx context.Context, network, address string) (Conn, error)
     }
     #+end_src
     
     Note that the ~Dial~ function optionally specifies an alternate dialer for
     use by Go's built-in DNS resolver to make TCP and UDP connections to DNS
     services. 
     
***** [[file:/usr/local/go/src/net/lookup.go::func%20(r%20*Resolver)%20LookupHost(ctx%20context.Context,%20host%20string)%20(addrs%20\%5B%5Dstring,%20err%20error)%20{][func (r *Resolver) LookupHost(ctx context.Context, host string) (addrs {}string, err error)]]
      Looks up the given host using the local resolver, note that *either IP
      address or hostname is supported* 
      
      If host is IP address, return IP parsed directly. Otherwise, call platform
      specific ~r.lookupHost~ to actually lookup the host

***** [[file:/usr/local/go/src/net/lookup.go::func%20(r%20*Resolver)%20LookupIPAddr(ctx%20context.Context,%20host%20string)%20(%5B%5DIPAddr,%20error)%20{][func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ({}IPAddr, error)]]
      Looks up host using the local resolver. *either IP or hostname is
      supported* 

      Details:
      - try to parse host as IP address. If successful, return IP address
        directly
      - If there're netrace variables in ~ctx~, call ~trace.DNSStart(host)~
      - Add 1 in ~dnsWaitGroup~, 
        [[dnsWaitGroup.Add(1)]]
        [[file:/usr/local/go/src/net/lookup.go::var%20dnsWaitGroup%20sync.WaitGroup][var dnsWaitGroup sync.WaitGroup]]
      - Then, start *only* one DNS request via ~loookupGroup.DoChan~, which is a
        method defined in ~singleflight.Grop~. I.e., however many goroutines
        there're that's trying to make DNS request, *only one* of them will
        actually run, all other goroutines will just wait for the result and use
        it when the result is ready.
        [[file:/usr/local/go/src/net/lookup.go::ch,%20called%20:%3D%20lookupGroup.DoChan(host,%20func()%20(interface{},%20error)%20{][ch, called := lookupGroup.DoChan(host, func() (interface{}, error) {]]
      - Then, blocks at ~select~ at channel, until either ~ctx.Done()~ channel
        or result channel ~ch~ is readable. 

        When ~ch~ is readable, i.e., DNS query returns successfully, returns the
        slice of ~IPAddr~. 

        When ~ctx.Done()~ is readable due to deadline exceeded, simply call
        ~lookupGroup.Forget(host)~ so that further DNS query will continue to
        start instead of wait

***** [[file:/usr/local/go/src/net/lookup.go::func%20(r%20*Resolver)%20LookupPort(ctx%20context.Context,%20network,%20service%20string)%20(port%20int,%20err%20error)%20{][func (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error) {]]
      Looks up the port for the given network and service

      Details:
      - Try to parse service as a number. 
        - If ~service~ is indeed a number, return the port no. directly.
        - Otherwise, call platform dependent ~Resolver.lookupPort~ to lookup the
          port no. and return it

***** Other methods omitted
      ~LookupCNAME~, ~LookupSRV~, ~LookupMX~, ~LookupNS~, ~LookupTXT~ are all simple
      wrappers over platform-dependent corresponding logic

      Pay special attention to ~LookupAddr~ method which performs reverse DNS
      lookup. 

*** Functions
**** [[file:/usr/local/go/src/net/lookup.go::func%20lookupProtocolMap(name%20string)%20(int,%20error)%20{][func lookupProtocolMap(name string) (int, error) {]]
     Given protocol name, return protocol number
    
**** [[file:/usr/local/go/src/net/lookup.go::func%20lookupPortMap(network,%20service%20string)%20(port%20int,%20error%20error)%20{][func lookupPortMap(network, service string) (port int, error error) {]]
     Given network(tcp or udp) and service name(http, https .etc), return the
     corresponding default port number

     
**** [[file:/usr/local/go/src/net/lookup.go::func%20LookupHost(host%20string)%20(addrs%20%5B%5Dstring,%20err%20error)%20{][func LookupHost(host string) (addrs {}string, err error)]]
     looks up the given host using the local default resolver. 
  
**** [[file:/usr/local/go/src/net/lookup.go::func%20LookupIP(host%20string)%20(%5B%5DIP,%20error)%20{][func LookupIP(host string) ({}IP, error)]]
     Looks up the given host's IP addresses 

**** [[file:/usr/local/go/src/net/lookup.go::func%20LookupPort(network,%20service%20string)%20(port%20int,%20err%20error)%20{][func LookupPort(network, service string) (port int, err error) {]]
     Given network and service, return the port no. 

     A simple wrapper of ~Resolver.LookupPort~ 

     Note that the Port lookup uses ~Background~ context which will never be
     canceled. 
     [[file:/usr/local/go/src/net/lookup.go::return%20DefaultResolver.LookupPort(context.Background(),%20network,%20service)][return DefaultResolver.LookupPort(context.Background(), network, service)]]
**** Other simple functions omitted
