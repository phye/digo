#+Title: Understanding Go STD
#+Author: Philip Ye(phye8080@gmail.com)
#+STARTUP: overview
#+STARTUP: hidestars

* context
  ~Context~ type carries deadlines, cancelation signals, and other
  request-scoped values across API boundaries and between processes. 

** context.go
*** Variables
**** [[file:/usr/local/go/src/context/context.go::var%20Canceled%20%3D%20errors.New("context%20canceled")][Canceled]]
     The error returned by ~Context.Err~ when the context is canceled

**** [[file:/usr/local/go/src/context/context.go::var%20DeadlineExceeded%20error%20%3D%20deadlineExceededError{}][DeadlineExceeded]]
     The error returned by ~Context.Err~ when the context's deadline passes

**** [[file:/usr/local/go/src/context/context.go::todo%20%3D%20new(emptyCtx)][todo = new(emptyCtx)]]
     The internal non-nil, empty Context
  
**** [[file:/usr/local/go/src/context/context.go::background%20%3D%20new(emptyCtx)][background = new(emptyCtx)]]
     The internal non-nil, empty Context named backgroud

*** Types
**** [[file:/usr/local/go/src/context/context.go::type%20emptyCtx%20int][type emptyCtx int]]
     An emptyCtx is never canceled, has no values, and has no deadline. Note that
     it is not struct{}, since vars of this type *must* have distinct addresses. 

     emptyCtx implements the following (empty) methods required by Context

     [[file:/usr/local/go/src/context/context.go::func%20(*emptyCtx)%20Deadline()%20(deadline%20time.Time,%20ok%20bool)%20{][func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {]]
     [[file:/usr/local/go/src/context/context.go::func%20(*emptyCtx)%20Done()%20<-chan%20struct{}%20{][func (*emptyCtx) Done() <-chan struct{} {]]
     [[file:/usr/local/go/src/context/context.go::func%20(*emptyCtx)%20Err()%20error%20{][func (*emptyCtx) Err() error {]]
     [[file:/usr/local/go/src/context/context.go::func%20(*emptyCtx)%20Value(key%20interface{})%20interface{}%20{][func (*emptyCtx) Value(key interface{}) interface{} {]]

**** [[file:/usr/local/go/src/context/context.go::type%20canceler%20interface%20{][type canceler interface {]]
     #+begin_src go
     type canceler interface {
         cancel(removeFromParent bool, err error)
         Done() <- chan struct{}
     }
     #+end_src
     A canceler is a context type that can be canceled directly. The
     implementations are ~*cancelCtx~ and ~*timerCtx~

**** [[file:/usr/local/go/src/context/context.go::type%20cancelCtx%20struct%20{][type cancelCtx struct {]]
     #+begin_src go
     type cancelCtx struct {
         Context                     // Note that, cancelCtx is a struct, not interface :)

         mu sync.Mutex
         done chan struct{}
         children map[canceler]struct{}
         err error
     }
     #+end_src

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*cancelCtx)%20Done()%20<-chan%20struct{}%20{][func (c *cancelCtx) Done() <-chan struct{} {]]
      *atomically* make a ~chan struct{}~ and return it. Note that calling
      ~cancelCtx.Done~ will override ~cancelCtx.Context.Done~. 

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*cancelCtx)%20Err()%20error%20{][func (c *cancelCtx) Err() error {]]
      *atomically* return c.err. Also override ~cnacelCtx.Context.Err~ 

***** Puzzles
      Why ~Deadline()~ and ~Value()~ are not implemented? 
      Since they're implemented in ~canCtx.Context~. 

      Note that cancelCtx is a struct, not an interface :) Thus the
      corresponding methods in ~canCtx.Context~ is sufficient.

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*cancelCtx)%20cancel(removeFromParent%20bool,%20err%20error)%20{][func (c *cancelCtx) cancel(removeFromParent bool, err error) {]]
      *Atomically* closes c.done, then cancels each of c's children. And if
      ~removeFromParent~ is true, removes c from its parent's ~children~ map
      
**** [[file:/usr/local/go/src/context/context.go::type%20timerCtx%20struct%20{][type timerCtx struct {]]
     #+begin_src go
     type timerCtx struct {
         cancelCtx
         timer *time.Timer // Under cancelCtx.mu.

         deadline time.Time
     }
     #+end_src

     A timerCtx *contains* a cancelCtx (which evetually contains a Context), but
     overrides the ~Context~'s Deadline() method

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*timerCtx)%20Deadline()%20(deadline%20time.Time,%20ok%20bool)%20{][/usr/local/go/src/context/context.go::func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {]]
      Simpler getter to return deadline

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*timerCtx)%20cancel(removeFromParent%20bool,%20err%20error)%20{][func (c *timerCtx) cancel(removeFromParent bool, err error) {]]
      Cancel the timerCtx and stop the timer
      - Cancel the inner cancelCtx first
      - Then, remove the context itself from the parent cancelCtx if
        ~removeFromParent~ is true
      - Lastly, stop timer atomically

**** [[file:/usr/local/go/src/context/context.go::type%20valueCtx%20struct%20{][type valueCtx struct {]]
     #+begin_src go
     type valueCtx struct {
         Context
         key, val interface{}
     }
     #+end_src

***** [[file:/usr/local/go/src/context/context.go::func%20(c%20*valueCtx)%20Value(key%20interface{})%20interface{}%20{][func (c *valueCtx) Value(key interface{}) interface{} {]]
      Return value that matches with key


**** [[file:/usr/local/go/src/context/context.go::type%20Context%20interface%20{][type Context interface {]]
     #+begin_src go
     type Context interface {
         Deadline() (deadline time.Time, ok bool)
         Done() <-chan struct{}
         Err() error
         Value(key interface{}) interface{}
     }
     #+end_src
     
     ~Deadline~ returns the time when work done on behalf of this context
     should be canceled. ~Deadline~ returns ok==false when no deadline is
     set. Successive calls to ~Deadline~ return the same results. 
     
     ~Done~ returns a channel that's closed when work don on behalf of this
     context should be canceled. Done may return nil if this context can never be
     canceled. Successive calls to Done return the same value.
     
     If ~Done~ is not yet closed, ~Err~ returns nil. If ~Done~ is closed, ~Err~
     returns a non-nil error explaining why: 

       - Canceled if the context was canceled
       - DeadlineExceeded if the context's deadline passed
       
     ~Value~ returns the value associated with this context for key, or nil if no
     value is associated with key. A key identifies a specific value in a
     Context. *A key can be any type that supports equality.*

**** [[file:/usr/local/go/src/context/context.go::type%20CancelFunc%20func()][type CancelFunc func()]]
     A CancelFunc tells an operation to abandon its work. After the first call,
     subsequent calls to a CancelFunc do nothing
     
*** Functions
**** [[file:/usr/local/go/src/context/context.go::func%20removeChild(parent%20Context,%20child%20canceler)%20{][func removeChild(parent Context, child canceler) {]]
     Remove ~child~ from ~parent~ context

**** [[file:/usr/local/go/src/context/context.go::func%20newCancelCtx(parent%20Context)%20cancelCtx%20{][func newCancelCtx(parent Context) cancelCtx {]]
     Return a new ~cancelCtx~ where ~parent~ is passed as the ~Context~ 

**** [[file:/usr/local/go/src/context/context.go::func%20parentCancelCtx(parent%20Context)%20(*cancelCtx,%20bool)%20{][func parentCancelCtx(parent Context) (*cancelCtx, bool) {]]
     Follows a chain of parent references until it finds a *cancelCtx. This
     function iterate over all the concrete ~Context~ types in the =context=
     package

**** [[file:/usr/local/go/src/context/context.go::func%20propagateCancel(parent%20Context,%20child%20canceler)%20{][func propagateCancel(parent Context, child canceler) {]]
     Summary: Arranges for child to be canceled when parent is. 
     1. If parent will never be canceled, return directly

     2. Otherwise, try to find the *nearest* parent ~cancelCtx~
        - If such one is found
          - Already canceled? 
            cancel child directly
          - Not canceled yet
            Insert child into parent ~cancelCtx~'s /children/ map *atomically*
        - Otherwise, do not have a parent cancelCtx
          Start a go routine to wait on parent's cancel channel and child's
          cancel channel
          - If parent is canceled, continue to cancel child
          - If child is canceld, nothing to do

            
**** [[file:/usr/local/go/src/context/context.go::func%20Background()%20Context%20{][func Background() Context {]]
     Return the internal background empty Context

**** [[file:/usr/local/go/src/context/context.go::func%20TODO()%20Context%20{][func TODO() Context {]]
     Return the internal todo empty Context

**** [[file:/usr/local/go/src/context/context.go::func%20WithCancel(parent%20Context)%20(ctx%20Context,%20cancel%20CancelFunc)%20{][func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {]]
     WithCancel returns a copy of parent with a new Done channel. The returned
     context's Done channel is closed when the returned cancel function is
     called or when the parent context's Done channel is closed, whichever
     happens first. 

**** [[file:/usr/local/go/src/context/context.go::func%20WithDeadline(parent%20Context,%20d%20time.Time)%20(Context,%20CancelFunc)%20{][func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {]]
     Summary: Returns a copy of the parent context with the deadline adjusted to
     be no later than d. The returned context's Done channel is closed *1)* when
     the deadline expires, *2)* when the returned cancel function is called, or
     *3)* when the parent context's Done channel is closed, whichever happens
     first.  

     - check if the parent's deadline is before myself; if yes, return
       cancelCtx with parent
     - Otherwise, create a new timerCtx with a new cancelCtx after parent and
       the deadline ~d~
     - Then, insert the new timerCtx into parent's children map
     - Then, check if the timer already expires
       - If yes 
         - cancel the newly created timerCtx directly
         - return the newly created timerCtx
       - Otherwise,
         - start a timer *atomically* with a callback to cancel the timerCtx
           after timer expires
         - Lastly, return the timerCtx and a new CancelFunc

**** [[file:/usr/local/go/src/context/context.go::func%20WithTimeout(parent%20Context,%20timeout%20time.Duration)%20(Context,%20CancelFunc)%20{][func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {]]
     Simple wrapper over WithDeadline for easy use

**** [[file:/usr/local/go/src/context/context.go::func%20WithValue(parent%20Context,%20key,%20val%20interface{})%20Context%20{][func WithValue(parent Context, key, val interface{}) Context {]]
     Return a new ValueCtx with key and val set. Note that ~key~ must be
     comparable and should not be of type string or other built-in type to avoid
     collisions between packages using context. 
* net 
** mac.go                                                                       :mac:
*** Types
**** [[file:/usr/local/go/src/net/mac.go::type%20HardwareAddr%20%5B%5Dbyte][HardwareAddr]]
     HardwareAddr represents a physical address
     
***** [[file:/usr/local/go/src/net/mac.go::func%20(a%20HardwareAddr)%20String()%20string%20{][String()]]
      Convert internal physical addr to human readable

***** [[file:/usr/local/go/src/net/mac.go::func%20ParseMAC(s%20string)%20(hw%20HardwareAddr,%20err%20error)%20{][ParseMAC(s string)]]
      Convert human readable MAC to internal byte slice based MAC
      Note that normally MAC address are of 6 bytes, however, there're also [[file:/usr/local/go/src/net/mac.go::/%2001:23:45:67:89:ab:cd:ef][8
      bytes]] and [[file:/usr/local/go/src/net/mac.go::/%2001:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00][20 bytes]] MAC 

** ip.go
*** Types
**** [[file:/usr/local/go/src/net/ip.go::type%20IP%20\%5B%5Dbyte][IP]]                                                                         :ip:
     IP is a single IP address, which can either by IPv4 or IPv6. 

***** [[file:/usr/local/go/src/net/ip.go::var%20v4InV6Prefix%20%3D%20%5B%5Dbyte{0,%200,%200,%200,%200,%200,%200,%200,%200,%200,%200xff,%200xff}][v4InV6Prefix (10 zeros, 2 0xFFs)]] 
      Note that IPv4 can be converted to IPv6 address by adding a canonical

***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20Equal(x%20IP)%20bool%20{][func (ip IP) Equal(x IP) bool {]]
      Compare if two IP are equal (taking IPv4 and IPv6 comparison into consideration)

***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20To4()%20IP%20{][func (ip IP) To4() IP {]]
***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20To16()%20IP%20{][func (ip IP) To16() IP {]]
      Two utils to convert IP to v4 or v6

***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20Mask(mask%20IPMask)%20IP%20{][func (ip IP) Mask(mask IPMask) IP {]]
      Return the result of masking the IP address ip with mask
    
***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20String()%20string%20{][func (ip IP) String() string {]]
      Return the string form of the IP address ip:
        - "<nil>", if ip has length 0
        - dotted form, for an IPv4 address
        - colon form: for IPv6
        - hexadecimal form of IP, without punctuation, if no other cases apply

***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20MarshalText()%20(\%5B%5Dbyte,%20error)%20{][func (ip *IP) MarshalText()]]
      Implements the encoding.TextMarshaler interface, *the encoding is the same as
      returned by String*. 

***** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20*IP)%20UnmarshalText(text%20%5B%5Dbyte)%20error%20{][func (ip *IP) UnmarshalText(text {}byte) error]]
      Implements the encoding.TextUnmarshaler interface, the IP address should be
      in dot form (for v4) or colon form (for v6)

**** [[file:/usr/local/go/src/net/ip.go::type%20IPMask%20\%5B%5Dbyte][IPMask]]                                                                     :ipmask:
***** [[file:/usr/local/go/src/net/ip.go::func%20(m%20IPMask)%20Size()%20(ones,%20bits%20int)%20{][func (m IPMask) Size() (ones, bits int) {]]
      Return number of leading ones and total bits in the mask

***** [[file:/usr/local/go/src/net/ip.go::func%20(m%20IPMask)%20String()%20string%20{][func (m IPMask) String() string {]]
      Return the hexadecimal form of IP, without punctuation

**** [[file:/usr/local/go/src/net/ip.go::type%20IPNet%20struct%20{][IPNet]]                                                                      :ipnet:
     IPNet represents an IP network with IP and IPMask

***** [[file:/usr/local/go/src/net/ip.go::func%20(n%20*IPNet)%20Contains(ip%20IP)%20bool%20{][func (n *IPNet) Contains(ip IP) bool {]]
      Returns whether the network includes ip

***** [[file:/usr/local/go/src/net/ip.go::func%20(n%20*IPNet)%20String()%20string%20{][func (n *IPNet) String() string {]]
      Returns the CIDR notation of n like "192.0.2.1/24", or "2001:db8::/48". Note
      that if the network is not in the canonical form, it will return mask as
      hexadecimal form without punctuation like "198.51.100.1/c000ff00"

*** Functions 
**** [[file:/usr/local/go/src/net/ip.go::func%20CIDRMask(ones,%20bits%20int)%20IPMask%20{][CIDRMask]] returns an IPMask 

**** [[file:/usr/local/go/src/net/ip.go::func%20ParseIP(s%20string)%20IP%20{][func ParseIP(s string) IP {]]
     Parse s as an IP address, returning the result. Support both IPv4 and IPv6.
   
**** [[file:/usr/local/go/src/net/ip.go::func%20ParseCIDR(s%20string)%20(IP,%20*IPNet,%20error)%20{][func ParseCIDR(s string) (IP, *IPNet, error) {]]
     Parses s as a CIDR notation IP address and prefix length, returns the IP
     address and the network implied by the IP and prefix length. 

**** TODO [[file:/usr/local/go/src/net/ip.go::func%20parseIPv6(s%20string,%20zoneAllowed%20bool)%20(ip%20IP,%20zone%20string)%20{][parseIPv6]]
     Parse IPv6 address

** net.go
   
*** Variables
**** [[file:/usr/local/go/src/net/net.go::var%20listenerBacklog%20%3D%20maxListenerBacklog()][var listenerBacklog = maxListenerBacklog()]]
    On Linux, return parsed info from =/proc/sys/net/core/somaxconn=

**** [[file:/usr/local/go/src/net/net.go::var%20threadLimit%20%3D%20make(chan%20struct{},%20500)][var threadLimit = make(chan struct{}, 500)]]
     Limit the number of cgo threads 

**** DONE Puzzle
     CLOSED: [2018-03-25 Sun 09:34]
     - State "DONE"       from "TODO"       [2018-03-25 Sun 09:34]
     Why there're two underscore variables ??

     #+begin_src go
     var (
         _ io.WriterTo = (*Buffers)(nil)
         _ io.Reader   = (*Buffers)(nil)
     )
     #+end_src

     Per [[https://golang.org/doc/effective_go.html#blank][effective go]], the blank identifiers above indicates that *the
     declaration exists only for the type checking, not to create a variable*. 

*** Types
**** [[file:/usr/local/go/src/net/net.go::type%20conn%20struct%20{][type conn struct {]]
     type ~conn~ is a simple wrapper over netFD, whose /internal/ implementation
     is platform dependent. 

     ~conn~ is a ~Conn~, with additional two methods for buffer SETTER. 
     
     #+begin_src go
     type conn struct {
         fd *netFD
     }
     #+end_src

***** [[file:/usr/local/go/src/net/net.go::func%20(c%20*conn)%20ok()%20bool%20{%20return%20c%20!%3D%20nil%20&&%20c.fd%20!%3D%20nil%20}][func (c *conn) ok() bool { return c != nil && c.fd != nil }]]
      Self-Explanatory

***** [[file:/usr/local/go/src/net/lookup_unix.go::func%20lookupProtocol(_%20context.Context,%20name%20string)%20(int,%20error)%20{][func (c *conn) Read(b {}byte) (int, error)]]
      Implements the Conn Read method which is done via ~conn.fd.Read~ 
***** [[file:/usr/local/go/src/net/net.go::func%20(c%20*conn)%20Write(b%20%5B%5Dbyte)%20(int,%20error)%20{][func (c *conn) Write(b {}byte) (int, error)]]
      Implements the Conn Write method which is done via ~conn.fd.Write~ 
***** [[file:/usr/local/go/src/net/net.go::func%20(c%20*conn)%20Close()%20error%20{][func (c *conn) Close() error {]]
      Closes the connection (required by ~Conn~)

***** [[file:/usr/local/go/src/net/net.go::func%20(c%20*conn)%20LocalAddr()%20Addr%20{][func (c *conn) LocalAddr() Addr {]]
***** [[file:/usr/local/go/src/net/net.go::func%20(c%20*conn)%20RemoteAddr()%20Addr%20{][func (c *conn) RemoteAddr() Addr {]]
      Simple wrappers over ~*netFD.fd~ fields. Required by ~Conn~ interface

***** [[file:/usr/local/go/src/net/net.go::func%20(c%20*conn)%20SetDeadline(t%20time.Time)%20error%20{][func (c *conn) SetDeadline(t time.Time) error {]]
***** [[file:/usr/local/go/src/net/net.go::func%20(c%20*conn)%20SetReadDeadline(t%20time.Time)%20error%20{][func (c *conn) SetReadDeadline(t time.Time) error {]]
***** [[file:/usr/local/go/src/net/net.go::func%20(c%20*conn)%20SetWriteDeadline(t%20time.Time)%20error%20{][func (c *conn) SetWriteDeadline(t time.Time) error {]]
      Wrappers over ~*netFD.fd.pdf~ methods. Required by ~Conn~ interface

***** [[file:/usr/local/go/src/net/net.go::func%20(c%20*conn)%20SetReadBuffer(bytes%20int)%20error%20{][func (c *conn) SetReadBuffer(bytes int) error {]]
***** [[file:/usr/local/go/src/net/net.go::func%20(c%20*conn)%20SetWriteBuffer(bytes%20int)%20error%20{][func (c *conn) SetWriteBuffer(bytes int) error {]]
      Simple Wrapper over ~setReadBuffer~ and ~setWriteBuffer~ 

***** [[file:/usr/local/go/src/net/net.go::func%20(c%20*conn)%20File()%20(f%20*os.File,%20err%20error)%20{][func (c *conn) File() (f *os.File, err error) {]]
      Per comments, *sets the underlying os.File to blocking mode* and returns a
      copy ~f~, which is independent of ~c~. 

      Note that the setting blocking is done in ~*netFD.fd.dup()~ 

**** [[file:/usr/local/go/src/net/net.go::type%20Addr%20interface%20{][type Addr interface {]]
     An interface that represents a network end point address

     #+begin_src go
     type Addr interface {
         Network() string // name of the network (for example, "tcp", "udp")
         String() string  // string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")
     }
     #+end_src

**** [[file:/usr/local/go/src/net/net.go::type%20Conn%20interface%20{][type Conn interface {]] 
     An interface indicating a generic *stream-oriented* network
     connection. Multiple goroutines may invoke methods on a Conn simultaneously 

     #+begin_src go
     type Conn interface {
         Read(b []byte) (n int, err error)
         Write(b []byte) (n int, err error)
         Close() error

         LocalAddr() Addr
         RemoteAddr() Addr

         SetDeadline(t time.Time) error
         SetReadDeadline(t time.Time) error
         SetWriteDeadline(t time.Time) error
     }
     #+end_src

     A Conn's interface can be divided into three parts:
       - IO related,
       - Address info related
       - Timeout related

**** [[file:/usr/local/go/src/net/net.go::type%20PacketConn%20interface%20{][type PacketCone interface {]]
     A generic packet-oriented network connection. Multiple goroutines may
     invoke methods on a PacketConn simultaneously  

     #+begin_src go
     type PacketConn interface {
         ReadFrom(b []byte) (n int, addr Addr, err error)
         WriteTo(b []byte, addr Addr) (n int, err error)
         Close() error

         LocalAddr() Addr

         SetDeadline(t time.Time) error
         SetReadDeadline(t time.Time) error
         SetWriteDeadline(t time.Time) error
     }
     #+end_src

**** [[file:/usr/local/go/src/net/net.go::type%20Listener%20interface%20{][type Listener interface {]]
     A generic network listener for stream-oriented protocols. Multiple
     goroutines may invoke methods on a Listener simultaneously. 

     #+begin_src go
     type Listener interface {
         // Accept waits for and returns the next connection to the listener.
         Accept() (Conn, error)

         // Close closes the listener.
         // Any blocked Accept operations will be unblocked and return errors.
         Close() error

         // Addr returns the listener's network address.
         Addr() Addr
     }
     #+end_src

**** [[file:/usr/local/go/src/net/net.go::type%20Error%20interface%20{][type Error interface {]]
     Embeds ~error~ interface with two additional methods: ~Timeout~ and
     ~Temporary~ 

**** [[file:/usr/local/go/src/net/net.go::type%20OpError%20struct%20{][type OpError struct {]]
     An error describes the operation, network type, and address of an error. 
**** [[file:/usr/local/go/src/net/net.go::type%20ParseError%20struct%20{][type ParseError struct {]]
     Error type of literal network address parsers
**** [[file:/usr/local/go/src/net/net.go::type%20AddrError%20struct%20{][type AddrError struct {]]
     Address error
**** [[file:/usr/local/go/src/net/net.go::type%20DNSConfigError%20struct%20{][type DNSConfigError struct {]]
**** [[file:/usr/local/go/src/net/net.go::type%20InvalidAddrError%20string][fype InvalidAddrError string]]
**** [[file:/usr/local/go/src/net/net.go::type%20UnknownNetworkError%20string][type UnknownNetworkError string]]
**** [[file:/usr/local/go/src/net/net.go::type%20DNSError%20struct%20{][type DNSError struct {]]
**** [[file:/usr/local/go/src/net/net.go::type%20buffersWriter%20interface%20{][type buffersWriter interface {]]

     #+begin_src go
     type buffersWriter interface {
         writeBuffers(*Buffers) (int64, error)
     }
     #+end_src
     
     ~buffersWriter~ is the *interface* implemented by Conns that support a
     "writev"-like batch write optimization. ~writerBuffers~ should fully consume
     all chunks from the provided Buffers, else it should report a non-nil
     error. 

**** [[file:/usr/local/go/src/net/net.go::func%20acquireThread()%20{][type Buffers {}{}byte]]
***** [[file:/usr/local/go/src/net/net.go::func%20(v%20*Buffers)%20WriteTo(w%20io.Writer)%20(n%20int64,%20err%20error)%20{][func (v *Buffers) WriteTo(w io.Writer) (n int64, err error) {]]
      Implements the ~WriteTo~ method required by ~io.WriterTo~ which will write
      all bytes to a writer until no more data to write or when an error occurs
***** [[file:/usr/local/go/src/net/net.go::func%20(v%20*Buffers)%20Read(p%20%5B%5Dbyte)%20(n%20int,%20err%20error)%20{][func (v *Buffers) Read(p {}byte) (n int, err error)]]
      a simple buffer read method

*** Functions
**** [[file:/usr/local/go/src/net/net.go::func%20acquireThread()%20{][func acquireThread() {]]
     Send message to ~threadLimit~ chan (which is a buffered chan of 500 slots) 
**** [[file:/usr/local/go/src/net/net.go::func%20releaseThread()%20{][func releaseThread() {]]
** fd_unix.go
*** Types
**** [[file:/usr/local/go/src/net/fd_unix.go::type%20netFD%20struct%20{][type netFD struct {]]
     #+begin_src go
          
     type netFD struct {
         pfd poll.FD

         // immutable until Close
         family      int
         sotype      int
         isConnected bool
         net         string
         laddr       Addr
         raddr       Addr
     }
     #+end_src

     Read carefully the doc of internal/poll
     #+BEGIN_QUOTE
     Package poll supports non-blocking I/O on file descriptors *with
     polling*. This supports I/O operations that *block only a goroutine*, not a
     thread. This is used by the net and os packages. It uses *a poller built
     into the runtime*, with support from the runtime scheduler. 
     #+END_QUOTE

***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20init()%20error%20{][func (fd *netFD) init() error {]]
      Init the FD by calling ~fd.pdf.Init(fd.net, true)~ to tell runtime netpoll
      to poll the fd

***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20setAddr(laddr,%20raddr%20Addr)%20{][func (fd *netFD) setAddr(laddr, raddr Addr) {]]
      SETTERs to set local and remote addr.
      Also, set finalizer for the fd via
      [[file:/usr/local/go/src/net/fd_unix.go::runtime.SetFinalizer(fd,%20(*netFD).Close)][runtime.SetFinalizer(fd, (*netFD).Close)]]
      So that user of the package does not need to close the FD explicitly
      (i.e., the garbage collector will close it for you) as long as GC find it
      suitable... 

***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20name()%20string%20{][func (fd *netFD) name() string {]]
      Simple function to return name of the fd in the format below:

      tcp: <local_addr>:<local_port> -> <remote_addr>:<remote_port>

***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20connect(ctx%20context.Context,%20la,%20ra%20syscall.Sockaddr)%20(rsa%20syscall.Sockaddr,%20ret%20error)%20{][func (fd *netFD) connect(ctx context.Context, la, ra syscall.Sockaddr) (rsa syscall.Sockaddr, ret error) {]]
      Connect to the remote address, 
      
      1. Call ~connectFunc~ (Defined in hook_unix.go, which should be
         syscall.Connect) 
         
         Switch error handdling based on error:
         - ~EINPROGRESS~, ~EALREADY~, or ~EINTR~, do noop and continue 
         - nil or ~EISCONN~, 
           Init ~fd.pdf~ again, and return nil ~rsa~

      2. If ctx has Deadline, associate write deadline with fd.pfd

      3. Then, start the /interrupter/ goroutine, if this context can be
         canceled. The /interrupter/ goroutine waits for the context to be done
         and interrupts the dial (by altering the fd's write deadline, which
         wakes up waitWrite)

      4. Lastly, performing the actual readable blocking wait
         [[file:/usr/local/go/src/net/fd_unix.go::if%20err%20:%3D%20fd.pfd.WaitWrite()%3B%20err%20!%3D%20nil%20{][if err := fd.pfd.WaitWrite(); err != nil {]]

      5. Lastly, if socket is connected successfully, i.e., SO_ERROR is 0, call
         ~syscall.Getpeername~ to get the remote peername

***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20Close()%20error%20{][func (fd *netFD) Close() error {]]
      Clear finalizer and close fd. 
      Simply call internal/poll.FD methods to perform action
      
***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20shutdown(how%20int)%20error%20{][func (fd *netFD) shutdown(how int) error {]]
***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20closeRead()%20error%20{][func (fd *netFD) closeRead() error {]]
***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20closeWrite()%20error%20{][func (fd *netFD) closeWrite() error {]]
      Shutown and variants
      Simply call internal/poll.FD methods to perform action

***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20Read(p%20%5B%5Dbyte)%20(n%20int,%20err%20error)%20{][func (fd *netFD) Read(p {}byte) (n int, err error)]]
***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20readFrom(p%20%5B%5Dbyte)%20(n%20int,%20sa%20syscall.Sockaddr,%20err%20error)%20{][func (fd *netFD) readFrom(p {}byte) (n int, sa syscall.Sockaddr, err error)]]
***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20readMsg(p%20%5B%5Dbyte,%20oob%20%5B%5Dbyte)%20(n,%20oobn,%20flags%20int,%20sa%20syscall.Sockaddr,%20err%20error)%20{][func (fd *netFD) readMsg(p {}byte, oob {}byte) (n, oobn, flags int, sa syscall.Sockaddr, err error)]]
      Read and variants
      Simply call internal/poll.FD methods to perform action

***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20Write(p%20%5B%5Dbyte)%20(nn%20int,%20err%20error)%20{][func (fd *netFD) Write(p {}byte) (nn int, err error)]]
***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20writeTo(p%20%5B%5Dbyte,%20sa%20syscall.Sockaddr)%20(n%20int,%20err%20error)%20{][func (fd *netFD) writeTo(p {}byte, sa syscall.Sockaddr) (n int, err error)]]
***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20writeMsg(p%20%5B%5Dbyte,%20oob%20%5B%5Dbyte,%20sa%20syscall.Sockaddr)%20(n%20int,%20oobn%20int,%20err%20error)%20{][func (fd *netFD) writeMsg(p {}byte, oob {}byte, sa syscall.Sockaddr) (n int, oobn int, err error)]]
      Write and vairants
      Simply call internal/poll.FD methods to perform action

***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20accept()%20(netfd%20*netFD,%20err%20error)%20{][func (fd *netFD) accept() (netfd *netFD, err error) {]]
      Call poll.FD.Accept method to accept a new socket connection in /d/ 
      
      Then, create a new /netfd/ with /d/ and fields in /fd/ to create a new
      /netfd/, init and setAddr for it


***** [[file:/usr/local/go/src/net/fd_unix.go::func%20(fd%20*netFD)%20dup()%20(f%20*os.File,%20err%20error)%20{][func (fd *netFD) dup() (f *os.File, err error) {]]
      *fd will be blocking after this function call!*

      Duplicate fd with an ~*os.File~, note that fd.pfd is set to blocking so
      that both the old fd and new fd are blocking (note that, O_BLOCKING is a
      field in open file descriptors, hence are shared across dup)
      
*** Functions
**** [[file:/usr/local/go/src/net/fd_unix.go::func%20newFD(sysfd,%20family,%20sotype%20int,%20net%20string)%20(*netFD,%20error)%20{][func newFD(sysfd, family, sotype int, net string) (*netFD, error) {]]
     /sysfd/: The int FD
     /family/: PF_INET, PF_LOCAL, PF_UNIX .etc
     /sotype/: socket type, i.e., SOCK_STREAM, SOCK_DGRAM .etc
     /net/: Network string
** DONE ipsock.go
   CLOSED: [2018-03-26 Mon 08:24]
   - State "DONE"       from "TODO"       [2018-03-26 Mon 08:24]
*** Types
**** [[file:/usr/local/go/src/net/ipsock.go::type%20ipStackCapabilities%20struct%20{][type ipStackCapabilities struct {]]
     Reports capabilities of IP stack, such as IPv4, IPv6, IPv4OverIPv6 .etc 

**** [[*][type addrList {}Addr]]
     Represents a list of network endpoint [[*%5B%5Bfile:/usr/local/go/src/net/net.go::type%2520Addr%2520interface%2520{%5D%5Btype%20Addr%20interface%20{%5D%5D][Addr]]
     
***** [[file:/usr/local/go/src/net/ipsock.go::func%20(addrs%20addrList)%20forResolve(network,%20addr%20string)%20Addr%20{][func (addrs addrList) forResolve(network, addr string) Addr {]]
      Returns the most appropriate address in /address/ for a call to
      ResolveTCPAddr, ResolveUDPAddr, or ResolveIPAddr

***** [[file:/usr/local/go/src/net/ipsock.go::func%20(addrs%20addrList)%20first(strategy%20func(Addr)%20bool)%20Addr%20{][func (addrs addrList) first(strategy func(Addr) bool) Addr {]]
      Returns the first address which satisfies strategy, or if none do, then
      the first address of any kind

      Pay special attention to ~strategy~ which is a function variable

***** [[file:/usr/local/go/src/net/ipsock.go::func%20(addrs%20addrList)%20partition(strategy%20func(Addr)%20bool)%20(primaries,%20fallbacks%20addrList)%20{][func (addrs addrList) partition(strategy func(Addr) bool) (primaries, fallbacks addrList) {]]

*** Functions
**** [[file:/usr/local/go/src/net/ipsock.go::func%20supportsIPv4()%20bool%20{][func supportsIPv4() bool {]]
**** [[file:/usr/local/go/src/net/ipsock.go::func%20supportsIPv6()%20bool%20{][func supportsIPv6() bool {]]
**** [[file:/usr/local/go/src/net/ipsock.go::func%20supportsIPv4map()%20bool%20{][func supportsIPv4map() bool {]]
     Simple GETTERs to return members of ~ipStackCaps~ which will invoke
     platform dependent ~ipStackCaps.probe~ *once*. 

**** [[file:/usr/local/go/src/net/ipsock.go::func%20isIPv4(addr%20Addr)%20bool%20{][func isIPv4(addr Addr) bool {]]
     reports whether addr contains an IPv4 address
     *Supported Addrs*: ~*TCPAddr~, ~*UDPAddr~, ~*IPAddr~

**** [[file:/usr/local/go/src/net/ipsock.go::func%20filterAddrList(filter%20func(IPAddr)%20bool,%20ips%20%5B%5DIPAddr,%20inetaddr%20func(IPAddr)%20Addr,%20originalAddr%20string)%20(addrList,%20error)%20{][func filterAddrList(filter func(IPAddr) bool, ips {}IPAddr, inetaddr func(IPAddr) Addr, original string) (addrList, error)]]
     applies a filter to a list of ~IPAddr~, and convert the filtered IPAddrs to
     a slice of [[*%5B%5Bfile:/usr/local/go/src/net/net.go::type%2520Addr%2520interface%2520{%5D%5Btype%20Addr%20interface%20{%5D%5D][Addr]]s

**** [[file:/usr/local/go/src/net/ipsock.go::func%20SplitHostPort(hostport%20string)%20(host,%20port%20string,%20err%20error)%20{][func SplitHostPort(hostport string) (host, port string, err error) {]]
     Splits a newtwork address of the form "host:port", "host%zone:port",
     "[host]:port", or "[host%zone]:port" into "host" or "host%zone" and "port" 

**** [[file:/usr/local/go/src/net/ipsock.go::func%20splitHostZone(s%20string)%20(host,%20zone%20string)%20{][func splitHostZone(s string) (host, zone string) {]]
**** [[file:/usr/local/go/src/net/ipsock.go::func%20JoinHostPort(host,%20port%20string)%20string%20{][func JoinHostPort(host, port string) string {]]
     Self Explanatory
**** [[file:/usr/local/go/src/net/ipsock.go::func%20loopbackIP(net%20string)%20IP%20{][func loopbackIP(net string) IP {]]
     Return an IPv6 or IPv4 loopback IP address
** lookup.go
*** Variables
**** [[file:/usr/local/go/src/net/ip.go::func%20(ip%20IP)%20MarshalText()%20(%5B%5Dbyte,%20error)%20{][dnsWaitGroup]]
     A internal wait group to wait for all goroutines to finish
    
**** [[file:/usr/local/go/src/net/lookup.go::var%20DefaultResolver%20%3D%20&Resolver{}][DefaultResolver]]
     Default *package-level* Lookup functions and by Dialers without a specified
     Resolver 
   
*** Types
**** [[file:/usr/local/go/src/net/lookup.go::type%20Resolver%20struct%20{][type Resolver struct {]]
     A ~Resolver~ looks up names and numbers. 

     #+begin_src go
     type Resolver struct {
         PreferGo bool
         StrictErrors bool
         Dial func(ctx context.Context, network, address string) (Conn, error)
     }
     #+end_src
     
     Note that the ~Dial~ function optionally specifies an alternate dialer for
     use by Go's built-in DNS resolver to make TCP and UDP connections to DNS
     services. 
     
***** [[file:/usr/local/go/src/net/lookup.go::func%20(r%20*Resolver)%20LookupHost(ctx%20context.Context,%20host%20string)%20(addrs%20\%5B%5Dstring,%20err%20error)%20{][func (r *Resolver) LookupHost(ctx context.Context, host string) (addrs {}string, err error)]]
      Looks up the given host using the local resolver, note that *either IP
      address or hostname is supported* 
      
      If host is IP address, return IP parsed directly. Otherwise, call platform
      specific ~r.lookupHost~ to actually lookup the host

***** [[file:/usr/local/go/src/net/lookup.go::func%20(r%20*Resolver)%20LookupIPAddr(ctx%20context.Context,%20host%20string)%20(%5B%5DIPAddr,%20error)%20{][func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ({}IPAddr, error)]]
      Looks up host using the local resolver. *either IP or hostname is
      supported* 

      Details:
      - try to parse host as IP address. If successful, return IP address
        directly
      - If there're netrace variables in ~ctx~, call ~trace.DNSStart(host)~
      - Add 1 in ~dnsWaitGroup~, 
        [[dnsWaitGroup.Add(1)]]
        [[file:/usr/local/go/src/net/lookup.go::var%20dnsWaitGroup%20sync.WaitGroup][var dnsWaitGroup sync.WaitGroup]]
      - Then, start *only* one DNS request via ~loookupGroup.DoChan~, which is a
        method defined in ~singleflight.Grop~. I.e., however many goroutines
        there're that's trying to make DNS request, *only one* of them will
        actually run, all other goroutines will just wait for the result and use
        it when the result is ready.
        [[file:/usr/local/go/src/net/lookup.go::ch,%20called%20:%3D%20lookupGroup.DoChan(host,%20func()%20(interface{},%20error)%20{][ch, called := lookupGroup.DoChan(host, func() (interface{}, error) {]]
      - Then, blocks at ~select~ at channel, until either ~ctx.Done()~ channel
        or result channel ~ch~ is readable. 

        When ~ch~ is readable, i.e., DNS query returns successfully, returns the
        slice of ~IPAddr~. 

        When ~ctx.Done()~ is readable due to deadline exceeded, simply call
        ~lookupGroup.Forget(host)~ so that further DNS query will continue to
        start instead of wait

***** [[file:/usr/local/go/src/net/lookup.go::func%20(r%20*Resolver)%20LookupPort(ctx%20context.Context,%20network,%20service%20string)%20(port%20int,%20err%20error)%20{][func (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error) {]]
      Looks up the port for the given network and service

      Details:
      - Try to parse service as a number. 
        - If ~service~ is indeed a number, return the port no. directly.
        - Otherwise, call platform dependent ~Resolver.lookupPort~ to lookup the
          port no. and return it

***** Other methods omitted
      ~LookupCNAME~, ~LookupSRV~, ~LookupMX~, ~LookupNS~, ~LookupTXT~ are all simple
      wrappers over platform-dependent corresponding logic

      Pay special attention to ~LookupAddr~ method which performs reverse DNS
      lookup. 

***** [[file:/usr/local/go/src/net/ipsock.go::func%20(r%20*Resolver)%20internetAddrList(ctx%20context.Context,%20net,%20addr%20string)%20(addrList,%20error)%20{][func (r *Resolver) internetAddrList(ctx context.Context, net, addr string) (addrList, error) {]]
      *Defined in [[*ipsock.go][ipsock.go]]*
      Resolves /addr/, which may be a literal IP address or a DNS name, and
      returns a list of internet protocol family addresses. 
      
      1. For TCP and UDP, split addr into host and port. Then lookup port no. via
         ~r.LookupPort~. For IP /net/, simply save addr to host
      2. Then, define an inner function ~inetaddr~, which convert an ~IPAddr~ to
         ~Addr~
      3. Try to convert host to IP address
         - Parse as IPv4 directly, if error, continue
         - Parse as IPv6 address, continue on error
         - Lastly, try to lookup the IP addr via DNS resolve
      4. Lastly, filter the addr list and returns IPs that's matching /net/


*** Functions
**** [[file:/usr/local/go/src/net/lookup.go::func%20lookupProtocolMap(name%20string)%20(int,%20error)%20{][func lookupProtocolMap(name string) (int, error) {]]
     Given protocol name, return protocol number
    
**** [[file:/usr/local/go/src/net/lookup.go::func%20lookupPortMap(network,%20service%20string)%20(port%20int,%20error%20error)%20{][func lookupPortMap(network, service string) (port int, error error) {]]
     Given network(tcp or udp) and service name(http, https .etc), return the
     corresponding default port number

     
**** [[file:/usr/local/go/src/net/lookup.go::func%20LookupHost(host%20string)%20(addrs%20%5B%5Dstring,%20err%20error)%20{][func LookupHost(host string) (addrs {}string, err error)]]
     looks up the given host using the local default resolver. 
  
**** [[file:/usr/local/go/src/net/lookup.go::func%20LookupIP(host%20string)%20(%5B%5DIP,%20error)%20{][func LookupIP(host string) ({}IP, error)]]
     Looks up the given host's IP addresses 

**** [[file:/usr/local/go/src/net/lookup.go::func%20LookupPort(network,%20service%20string)%20(port%20int,%20err%20error)%20{][func LookupPort(network, service string) (port int, err error) {]]
     Given network and service, return the port no. 

     A simple wrapper of ~Resolver.LookupPort~ 

     Note that the Port lookup uses ~Background~ context which will never be
     canceled. 
     [[file:/usr/local/go/src/net/lookup.go::return%20DefaultResolver.LookupPort(context.Background(),%20network,%20service)][return DefaultResolver.LookupPort(context.Background(), network, service)]]
**** Other simple functions omitted
